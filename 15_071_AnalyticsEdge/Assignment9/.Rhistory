#################################
# a) i
#################################
# We set directed=F for undirected graphs
G = graph.data.frame(senateCos, directed=F, senators)
set.seed(144)
mylayout = layout.auto(G) # generates spatial locations for plotting the nodes
# First, try just plain plot function
plot(G, layout=mylayout)
# quite ugly!
# Let's fix the margins of our graph
par(mar=c(0, 0, 0, 0))
plot(G, layout=mylayout)
# Still a mess - let's try to make it nicer
# Remove the node labels (vertex.label=NA), and let the
# size vary proportional to the square root of degree (i.e., # of neighbors)
plot(G, layout=mylayout, vertex.label=NA, vertex.size=3*sqrt(degree(G)))
# What if we wanted to color the nodes depending on the program?
col <- ifelse(V(G)$party == "R", "red",
ifelse(V(G)$party == "D", "blue", "white"))
# V(G)$program contains the program information from "info"
# This will color MBA 2018s in green, MBA 2019s in blue, and others in red
plot(G, layout=mylayout, vertex.label=NA, vertex.size=3*sqrt(degree(G)),
vertex.color = col)
### PART II:      Network metrics           ######
# From now on, we are only going to work with
# students who are in the largest connected
# component of the graph
comp = components(G)
# inspect the membership
comp$membership
table(comp$membership)
# only keep those that are in the largest component (component #1)
in.max.comp = (comp$membership == 1) # this is a vector of TRUE/FALSE
sg = induced_subgraph(G, in.max.comp) # this gives us a new graph object
# get the sub layout, based on the layout used for the entire dataset
sg_mylayout = mylayout[in.max.comp,]
col <- ifelse(V(sg)$program == "R", "red",
ifelse(V(sg)$program == "D", "blue", "white"))
#???????G???[?ɂȂ?
plot(sg, layout=sg_mylayout, vertex.label=NA, vertex.size=3*sqrt(degree(sg)), vertex.color = col)
sg_mylayout
mode(sg_mylayout)
############################################
###     Recitation 10 - Social Networks   ###
# install igraph package
install.packages("igraph")
install.packages("igraph")
# install RColorBrewer to make nice colors
install.packages("RColorBrewer")
############################################
###     Recitation 10 - Social Networks   ###
# install igraph package
# install.packages("igraph")
# install RColorBrewer to make nice colors
# install.packages("RColorBrewer")
# load in the packages
library(igraph)
library(RColorBrewer)
### Part I: visualization                ###
# read in the nodes and edges data
info = read.csv("nodes_15071_anon.csv")
links = read.csv("edges_15071_anon.csv")
# First, let's take a look:
head(info)
# the node data provides the index of the nodes
# as well as the "program" attribute (undergrad, MBA 2018, etc.)
# and the "section" attribute (A or B)
head(links)
# We set directed=F for undirected graphs
G = graph.data.frame(links, directed=F, info)
# How do we plot our graph G?
# plotting a graph is separated into two steps:
# - layout (there are many ways to do this)
# - plotting (actually draws it)
# we set the seed so the layout is the same
set.seed(144)
mylayout = layout.auto(G) # generates spatial locations for plotting the nodes
# First, try just plain plot function
plot(G, layout=mylayout)
# quite ugly!
# Let's fix the margins of our graph
par(mar=c(0, 0, 0, 0))
plot(G, layout=mylayout)
# Still a mess - let's try to make it nicer
# Remove the node labels (vertex.label=NA), and let the
# size vary proportional to the square root of degree (i.e., # of neighbors)
plot(G, layout=mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(G)))
# What if we wanted to color the nodes depending on the program?
col <- ifelse(V(G)$program == "MBA 2018", "green",
ifelse(V(G)$program == "MBA 2019", "blue", "red"))
# V(G)$program contains the program information from "info"
# This will color MBA 2018s in green, MBA 2019s in blue, and others in red
plot(G, layout=mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(G)),
vertex.color = col)
### ALERT: EXPERT ONLY ####
# get.colors is a function that we've written -- it takes
# as input two colors (the color for low values and
# the color for high values) as well as values (x) and it
# returns the color for each value.
get.colors = function(cols, x) {
ramp = colorRamp(cols)
apply(ramp(x/max(x)), 1, function(y) rgb(y[1]/255, y[2]/255, y[3]/255))
}
# You don't need to understand or change get.colors
# to use it when plotting:
plot(G, layout=mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(G)),
vertex.color = get.colors(c("white", "purple"), degree(G)))
### PART II:      Network metrics           ######
# From now on, we are only going to work with
# students who are in the largest connected
# component of the graph
comp = components(G)
# inspect the membership
comp$membership
table(comp$membership)
# only keep those that are in the largest component (component #1)
in.max.comp = (comp$membership == 1) # this is a vector of TRUE/FALSE
sg = induced_subgraph(G, in.max.comp) # this gives us a new graph object
# get the sub layout, based on the layout used for the entire dataset
sg_mylayout = mylayout[in.max.comp,]
col <- ifelse(V(sg)$program == "MBA 2018", "green",
ifelse(V(sg)$program == "MBA 2019", "blue", "red"))
plot(sg, layout=sg_mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(sg)), vertex.color = col)
mode(sg_mylayout)
sg_mylayout
# First, try just plain plot function
plot(G, layout=mylayout)
# quite ugly!
# Let's fix the margins of our graph
par(mar=c(0, 0, 0, 0))
plot(G, layout=mylayout)
# Still a mess - let's try to make it nicer
# Remove the node labels (vertex.label=NA), and let the
# size vary proportional to the square root of degree (i.e., # of neighbors)
plot(G, layout=mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(G)))
# What if we wanted to color the nodes depending on the program?
col <- ifelse(V(G)$program == "MBA 2018", "green",
ifelse(V(G)$program == "MBA 2019", "blue", "red"))
# V(G)$program contains the program information from "info"
# This will color MBA 2018s in green, MBA 2019s in blue, and others in red
plot(G, layout=mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(G)),
vertex.color = col)
### ALERT: EXPERT ONLY ####
# get.colors is a function that we've written -- it takes
# as input two colors (the color for low values and
# the color for high values) as well as values (x) and it
# returns the color for each value.
get.colors = function(cols, x) {
ramp = colorRamp(cols)
apply(ramp(x/max(x)), 1, function(y) rgb(y[1]/255, y[2]/255, y[3]/255))
}
# You don't need to understand or change get.colors
# to use it when plotting:
plot(G, layout=mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(G)),
vertex.color = get.colors(c("white", "purple"), degree(G)))
### PART II:      Network metrics           ######
# From now on, we are only going to work with
# students who are in the largest connected
# component of the graph
comp = components(G)
?components
comp
G
table(comp$membership)
in.max.comp
?induced_subgraph
sg
mylayout[in.max.comp,]
mylayout
mylayout
in.max.comp
sg_mylayout
#################################
# a) i
#################################
# We set directed=F for undirected graphs
G = graph.data.frame(senateCos, directed=F, senators)
set.seed(144)
mylayout = layout.auto(G) # generates spatial locations for plotting the nodes
mylayout
# First, try just plain plot function
plot(G, layout=mylayout)
# quite ugly!
# Let's fix the margins of our graph
par(mar=c(0, 0, 0, 0))
plot(G, layout=mylayout)
# Still a mess - let's try to make it nicer
# Remove the node labels (vertex.label=NA), and let the
# size vary proportional to the square root of degree (i.e., # of neighbors)
plot(G, layout=mylayout, vertex.label=NA, vertex.size=3*sqrt(degree(G)))
# What if we wanted to color the nodes depending on the program?
col <- ifelse(V(G)$party == "R", "red",
ifelse(V(G)$party == "D", "blue", "white"))
# V(G)$program contains the program information from "info"
# This will color MBA 2018s in green, MBA 2019s in blue, and others in red
plot(G, layout=mylayout, vertex.label=NA, vertex.size=3*sqrt(degree(G)),
vertex.color = col)
### PART II:      Network metrics           ######
# From now on, we are only going to work with
# students who are in the largest connected
# component of the graph
comp = components(G)
comp
# inspect the membership
comp$membership
table(comp$membership)
# only keep those that are in the largest component (component #1)
in.max.comp = (comp$membership == 1) # this is a vector of TRUE/FALSE
in.max.comp
sg = induced_subgraph(G, in.max.comp) # this gives us a new graph object
sg
# get the sub layout, based on the layout used for the entire dataset
sg_mylayout = mylayout[in.max.comp,]
sg_mylayout
matrix(1,4,5,3)
matrix(1:6,4,5,3)
matrix(1:6,4,3)
matrix(1:6,4,2)
sg_mylayout = matrix(1:6,4,2)
col <- ifelse(V(sg)$program == "R", "red",
ifelse(V(sg)$program == "D", "blue", "white"))
#???????G???[?ɂȂ?
plot(sg, layout=sg_mylayout, vertex.label=NA, vertex.size=3*sqrt(degree(sg)), vertex.color = col)
# inspect the membership
comp$membership
table(comp$membership)
head(senateCos)
# the node data provides the index of the nodes
# as well as the "program" attribute (undergrad, MBA 2018, etc.)
# and the "section" attribute (A or B)
head(links)
mylayout
### PART II:      Network metrics           ######
# From now on, we are only going to work with
# students who are in the largest connected
# component of the graph
comp = components(G)
# inspect the membership
comp$membership
table(comp$membership)
#################################
# a) i
#################################
# We set directed=F for undirected graphs
G = graph.data.frame(senateCos, directed=F, senators)
set.seed(144)
mylayout = layout.auto(G) # generates spatial locations for plotting the nodes
# What if we wanted to color the nodes depending on the program?
col <- ifelse(V(G)$party == "R", "red",
ifelse(V(G)$party == "D", "blue", "white"))
### PART II:      Network metrics           ######
# From now on, we are only going to work with
# students who are in the largest connected
# component of the graph
comp = components(G)
# inspect the membership
comp$membership
table(comp$membership)
# We set directed=F for undirected graphs
G = graph.data.frame(links, directed=F, info)
# How do we plot our graph G?
# plotting a graph is separated into two steps:
# - layout (there are many ways to do this)
# - plotting (actually draws it)
# we set the seed so the layout is the same
set.seed(144)
mylayout = layout.auto(G) # generates spatial locations for plotting the nodes
# What if we wanted to color the nodes depending on the program?
col <- ifelse(V(G)$program == "MBA 2018", "green",
ifelse(V(G)$program == "MBA 2019", "blue", "red"))
### PART II:      Network metrics           ######
# From now on, we are only going to work with
# students who are in the largest connected
# component of the graph
comp = components(G)
# inspect the membership
comp$membership
table(comp$membership)
in.max.comp
# only keep those that are in the largest component (component #1)
in.max.comp = (comp$membership == 1) # this is a vector of TRUE/FALSE
in.max.comp
sg = induced_subgraph(G, in.max.comp) # this gives us a new graph object
sg
#################################
# a) i
#################################
# We set directed=F for undirected graphs
G = graph.data.frame(senateCos, directed=F, senators)
set.seed(144)
mylayout = layout.auto(G) # generates spatial locations for plotting the nodes
# First, try just plain plot function
plot(G, layout=mylayout)
### PART II:      Network metrics           ######
# From now on, we are only going to work with
# students who are in the largest connected
# component of the graph
comp = components(G)
# inspect the membership
comp$membership
table(comp$membership)
sg_mylayout
# get the sub layout, based on the layout used for the entire dataset
sg_mylayout = mylayout[in.max.comp,]
# only keep those that are in the largest component (component #1)
in.max.comp = (comp$membership == 1) # this is a vector of TRUE/FALSE
sg = induced_subgraph(G, in.max.comp) # this gives us a new graph object
# get the sub layout, based on the layout used for the entire dataset
sg_mylayout = mylayout[in.max.comp,]
sg_mylayout
# We set directed=F for undirected graphs
G = graph.data.frame(links, directed=F, info)
# How do we plot our graph G?
# plotting a graph is separated into two steps:
# - layout (there are many ways to do this)
# - plotting (actually draws it)
# we set the seed so the layout is the same
set.seed(144)
mylayout = layout.auto(G) # generates spatial locations for plotting the nodes
# First, try just plain plot function
plot(G, layout=mylayout)
# quite ugly!
# Let's fix the margins of our graph
par(mar=c(0, 0, 0, 0))
plot(G, layout=mylayout)
# Still a mess - let's try to make it nicer
# Remove the node labels (vertex.label=NA), and let the
# size vary proportional to the square root of degree (i.e., # of neighbors)
plot(G, layout=mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(G)))
# What if we wanted to color the nodes depending on the program?
col <- ifelse(V(G)$program == "MBA 2018", "green",
ifelse(V(G)$program == "MBA 2019", "blue", "red"))
# V(G)$program contains the program information from "info"
# This will color MBA 2018s in green, MBA 2019s in blue, and others in red
plot(G, layout=mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(G)),
vertex.color = col)
### PART II:      Network metrics           ######
# From now on, we are only going to work with
# students who are in the largest connected
# component of the graph
comp = components(G)
# inspect the membership
comp$membership
table(comp$membership)
# only keep those that are in the largest component (component #1)
in.max.comp = (comp$membership == 1) # this is a vector of TRUE/FALSE
in.max.comp
in.max.comp
sg = induced_subgraph(G, in.max.comp) # this gives us a new graph object
sg
# get the sub layout, based on the layout used for the entire dataset
sg_mylayout = mylayout[in.max.comp,]
sg_mylayout
#################################
# a) i
#################################
# We set directed=F for undirected graphs
G = graph.data.frame(senateCos, directed=F, senators)
set.seed(144)
mylayout = layout.auto(G) # generates spatial locations for plotting the nodes
### PART II:      Network metrics           ######
# From now on, we are only going to work with
# students who are in the largest connected
# component of the graph
comp = components(G)
# inspect the membership
comp$membership
table(comp$membership)
comp
# inspect the membership
comp$membership
#################################
# a) i
#################################
# We set directed=F for undirected graphs
G = graph.data.frame(senateCos, directed=F, senators)
G
mylayout = layout.auto(G) # generates spatial locations for plotting the nodes
# First, try just plain plot function
plot(G, layout=mylayout)
# quite ugly!
# Let's fix the margins of our graph
par(mar=c(0, 0, 0, 0))
plot(G, layout=mylayout)
# Still a mess - let's try to make it nicer
# Remove the node labels (vertex.label=NA), and let the
# size vary proportional to the square root of degree (i.e., # of neighbors)
plot(G, layout=mylayout, vertex.label=NA, vertex.size=3*sqrt(degree(G)))
# What if we wanted to color the nodes depending on the program?
col <- ifelse(V(G)$party == "R", "red",
ifelse(V(G)$party == "D", "blue", "white"))
# V(G)$program contains the program information from "info"
# This will color MBA 2018s in green, MBA 2019s in blue, and others in red
plot(G, layout=mylayout, vertex.label=NA, vertex.size=3*sqrt(degree(G)),
vertex.color = col)
# We set directed=F for undirected graphs
G = graph.data.frame(links, directed=F, info)
# How do we plot our graph G?
# plotting a graph is separated into two steps:
# - layout (there are many ways to do this)
# - plotting (actually draws it)
# we set the seed so the layout is the same
set.seed(144)
mylayout = layout.auto(G) # generates spatial locations for plotting the nodes
# First, try just plain plot function
plot(G, layout=mylayout)
# quite ugly!
# Let's fix the margins of our graph
par(mar=c(0, 0, 0, 0))
plot(G, layout=mylayout)
# Still a mess - let's try to make it nicer
# Remove the node labels (vertex.label=NA), and let the
# size vary proportional to the square root of degree (i.e., # of neighbors)
plot(G, layout=mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(G)))
# What if we wanted to color the nodes depending on the program?
col <- ifelse(V(G)$program == "MBA 2018", "green",
ifelse(V(G)$program == "MBA 2019", "blue", "red"))
# V(G)$program contains the program information from "info"
# This will color MBA 2018s in green, MBA 2019s in blue, and others in red
plot(G, layout=mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(G)),
vertex.color = col)
### PART II:      Network metrics           ######
# From now on, we are only going to work with
# students who are in the largest connected
# component of the graph
comp = components(G)
# inspect the membership
comp$membership
table(comp$membership)
# only keep those that are in the largest component (component #1)
in.max.comp = (comp$membership == 1) # this is a vector of TRUE/FALSE
sg = induced_subgraph(G, in.max.comp) # this gives us a new graph object
# get the sub layout, based on the layout used for the entire dataset
sg_mylayout = mylayout[in.max.comp,]
col <- ifelse(V(sg)$program == "MBA 2018", "green",
ifelse(V(sg)$program == "MBA 2019", "blue", "red"))
plot(sg, layout=sg_mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(sg)), vertex.color = col)
# You don't need to understand or change get.colors
# to use it when plotting:
plot(G, layout=mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(G)),
vertex.color = get.colors(c("white", "purple"), degree(G)))
# V(G)$program contains the program information from "info"
# This will color MBA 2018s in green, MBA 2019s in blue, and others in red
plot(G, layout=mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(G)),
vertex.color = col)
# V(G)$program contains the program information from "info"
# This will color MBA 2018s in green, MBA 2019s in blue, and others in red
plot(G, layout=mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(G)),
vertex.color = col)
plot(sg, layout=sg_mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(sg)), vertex.color = col)
# V(G)$program contains the program information from "info"
# This will color MBA 2018s in green, MBA 2019s in blue, and others in red
plot(G, layout=mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(G)),
vertex.color = col)
plot(sg, layout=sg_mylayout, vertex.label=NA, vertex.size=2*sqrt(degree(sg)), vertex.color = col)
sg
layout
sg_mylayout
# First, let's take a look:
head(info)
# the node data provides the index of the nodes
# as well as the "program" attribute (undergrad, MBA 2018, etc.)
# and the "section" attribute (A or B)
head(links)
G
sg_mylayout
mode(sg_mylayout)
comp
?components
comp
### PART II:      Network metrics           ######
# From now on, we are only going to work with
# students who are in the largest connected
# component of the graph
comp = components(G)
# inspect the membership
comp$membership
G
### END ALERT ###
length(G)
dim(G)
### PART II:      Network metrics           ######
# From now on, we are only going to work with
# students who are in the largest connected
# component of the graph
comp = components(G, cumulative=TRUE)
### PART II:      Network metrics           ######
# From now on, we are only going to work with
# students who are in the largest connected
# component of the graph
comp = components(G, mode = c("weak", "strong"))
comp
comp
# inspect the membership
comp$membership
table(comp$membership)
#################################
# a) i
#################################
# We set directed=F for undirected graphs
G = graph.data.frame(senateCos, directed=F, senators)
set.seed(144)
mylayout = layout.auto(G) # generates spatial locations for plotting the nodes
### PART II:      Network metrics           ######
# From now on, we are only going to work with
# students who are in the largest connected
# component of the graph
comp = components(G,  mode = c("weak", "strong"))
# inspect the membership
comp$membership
table(comp$membership)
